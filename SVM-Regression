

# # Support Vector Machines
# ## SVM - Regression

# The concrete slump test measures the consistency of fresh concrete before it sets. It is performed to check the workability of freshly made concrete, and therefore the ease with which concrete flows. It can also be used as an indicator of an improperly mixed batch.
# 
# <img src="Types_of_concrete_slump.jpg">
# 
# Our data set consists of various cement properties and the resulting slump test metrics in cm. Later on the set concrete is tested for its compressive strength 28 days later.
# 
# Input variables (7)(component kg in one M^3 concrete):
# * Cement
# * Slag
# * Fly ash
# * Water
# * SP
# * Coarse Aggr.
# * Fine Aggr.
# 
# Output variables (3):
# * SLUMP (cm)
# * FLOW (cm)
# * **28-day Compressive Strength (Mpa)**
# 
# Data Source: https://archive.ics.uci.edu/ml/datasets/Concrete+Slump+Test
# 
# *Credit: Yeh, I-Cheng, "Modeling slump flow of concrete using second-order regressions and artificial neural networks," Cement and Concrete Composites, Vol.29, No. 6, 474-480, 2007.*

# In[1]:


import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt


# In[2]:


df = pd.read_csv('../cement_slump.csv')


# In[3]:


df.head()


# In[4]:


df.corr()['Compressive Strength (28-day)(Mpa)']


# In[5]:


sns.heatmap(df.corr(),cmap='viridis')


# In[6]:


df.columns


# ## Train | Test Split
# 
# Alternatively you could also set this up as a pipline, something like:
# 
#     >>> from sklearn.pipeline import make_pipeline
#     >>> from sklearn.preprocessing import StandardScaler
#     >>> from sklearn.svm import SVR
# 
#     >>> clf = make_pipeline(StandardScaler(), SVR())

# In[7]:


df.columns


# In[8]:


X = df.drop('Compressive Strength (28-day)(Mpa)',axis=1)
y = df['Compressive Strength (28-day)(Mpa)']


# In[9]:


from sklearn.model_selection import train_test_split


# In[10]:


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=101)


# In[11]:


from sklearn.preprocessing import StandardScaler


# In[12]:


scaler = StandardScaler()


# In[13]:


scaled_X_train = scaler.fit_transform(X_train)
scaled_X_test = scaler.transform(X_test)


# ## Support Vector Machines - Regression
# 
# There are three different implementations of Support Vector Regression: SVR, NuSVR and LinearSVR. LinearSVR provides a faster implementation than SVR but only considers the linear kernel, while NuSVR implements a slightly different formulation than SVR and LinearSVR. See [Implementation details](https://scikit-learn.org/stable/modules/svm.html#svm-implementation-details) for further details.

# In[14]:


from sklearn.svm import SVR,LinearSVR


# Setting C: C is 1 by default and itâ€™s a reasonable default choice. If you have a lot of noisy observations you should decrease it: decreasing C corresponds to more regularization.
# 
# LinearSVC and LinearSVR are less sensitive to C when it becomes large, and prediction results stop improving after a certain threshold. Meanwhile, larger C values will take more time to train, sometimes up to 10 times longer
# 

# In[15]:


base_model = SVR()


# In[16]:


base_model.fit(scaled_X_train,y_train)


# In[17]:


base_preds = base_model.predict(scaled_X_test)


# ## Evaluation

# In[18]:


from sklearn.metrics import mean_absolute_error,mean_squared_error


# In[19]:


mean_absolute_error(y_test,base_preds)


# In[20]:


np.sqrt(mean_squared_error(y_test,base_preds))


# In[21]:


y_test.mean()


# ## Grid Search in Attempt for Better Model

# In[22]:


param_grid = {'C':[0.001,0.01,0.1,0.5,1],
             'kernel':['linear','rbf','poly'],
              'gamma':['scale','auto'],
              'degree':[2,3,4],
              'epsilon':[0,0.01,0.1,0.5,1,2]}


# In[23]:


from sklearn.model_selection import GridSearchCV


# In[24]:


svr = SVR()
grid = GridSearchCV(svr,param_grid=param_grid)


# In[25]:


grid.fit(scaled_X_train,y_train)


# In[26]:


grid.best_params_


# In[27]:


grid_preds = grid.predict(scaled_X_test)


# In[28]:


mean_absolute_error(y_test,grid_preds)


# In[29]:


np.sqrt(mean_squared_error(y_test,grid_preds))

